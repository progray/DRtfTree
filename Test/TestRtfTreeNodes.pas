unit TestRtfTreeNodes;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, StrUtils, Classes, SysUtils, TestRtfBase, RtfTree;

type

  TTestRtfTreeNodes = class(TRtfTestCase)
  strict private
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestPopulate;
    procedure TestIndex;
  end;

implementation

procedure TTestRtfTreeNodes.SetUp;
begin
end;

procedure TTestRtfTreeNodes.TearDown;
begin
end;

procedure TTestRtfTreeNodes.TestPopulate;
var
  List1: TRtfTreeNodes;
  ANode1, ANode2: TRtfTreeNode;

begin
  List1 := TRtfTreeNodes.Create;
  try
    // test add
    ANode1 := TRtfTreeNode.Create(ntKeyword, 'b', True, 2);
    List1.Add(TRtfTreeNode.Create(ntKeyword, 'a', True, 1));
    List1.Add(ANode1);
    List1.Add(TRtfTreeNode.Create(ntKeyword, 'c', True, 3));
    List1.Add(TRtfTreeNode.Create(ntKeyword, 'd', True, 4));
    List1.Add(TRtfTreeNode.Create(ntKeyword, 'e', True, 5));

    CheckEquals(5, List1.Count, 'List has 5 childs');
    Check(ANode1 = List1[1], 'Added node has same object');

    // test insert
    ANode2 := TRtfTreeNode.Create(ntKeyword, 'f', False, 6);
    List1.Insert(1, ANode2);
    CheckEquals(6, List1.Count, 'List count matched after a node is inserted');
    CheckEquals('f', List1[1].NodeKey, 'Inserted node has same object');

    // test remove
    List1.Remove(1);
    CheckEquals(5, List1.Count, 'List count matched after a node is removed');
    CheckEquals('b', List1[1].NodeKey, 'Object matched after a node is removed');
    List1.Remove(1, 2);
    CheckEquals(3, List1.Count, 'List count matched after range of node is removed');
    CheckEquals('d', List1[1].NodeKey, 'Object matched after range of node is removed');
  finally
    FreeAndNil(List1);
  end;
end;

procedure TTestRtfTreeNodes.TestIndex;
var
  List1: TRtfTreeNodes;
  ANode1, ANode2: TRtfTreeNode;

begin
  List1 := TRtfTreeNodes.Create;
  try
    ANode1 := TRtfTreeNode.Create(ntKeyword, 'c', True, 3);
    List1.Add(TRtfTreeNode.Create(ntKeyword, 'a', True, 1));
    List1.Add(TRtfTreeNode.Create(ntKeyword, 'b', True, 2));
    List1.Add(ANode1);
    List1.Add(TRtfTreeNode.Create(ntKeyword, 'b', True, 4));
    ANode2 := ANode1.CloneNode;
    List1.Add(ANode2);
    List1.Add(TRtfTreeNode.Create(ntKeyword, 'e', True, 6));

    // index by object
    CheckEquals( 2, List1.IndexOf(ANode1), 'Index of object matched');
    CheckEquals(-1, List1.IndexOf(TRtfTreeNode.Create), 'Index of non existent object should be -1');
    CheckEquals( 2, List1.IndexOf(ANode1, 0), 'Index of object matched if start index specified');
    CheckEquals(-1, List1.IndexOf(ANode1, 5), 'Index of object should be -1 if start index specified and out of range');

    // index by node key
    CheckEquals( 1, List1.IndexOf('b'), 'Index of node key matched');
    CheckEquals(-1, List1.IndexOf('x'), 'Index of non existent node key should -1');
    CheckEquals( 1, List1.IndexOf('b', 1), 'Index of node key matched if start index specified');
    CheckEquals( 3, List1.IndexOf('b', 2), 'Index of node key matched if start index specified');
    CheckEquals(-1, List1.IndexOf('x', 0), 'Index of node key should -1 if start index specified and out of range');
  finally
    FreeAndNil(List1);
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TTestRtfTreeNodes.Suite);

end.

